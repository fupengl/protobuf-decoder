{"version":3,"sources":["hexUtils.js","varintUtils.js","protobufDecoder.js","protobufPartDecoder.js","ProtobufPart.js","ProtobufDisplay.js","App.js","index.js"],"names":["parseInput","input","normalizedInput","replace","normalizedHexInput","toLowerCase","string","result","char","isHex","Buffer","from","bufferToPrettyHex","buffer","output","v","hex","toString","length","bufferLeToBeHex","BIGINT_1","JSBI","BigInt","BIGINT_2","BufferReader","this","offset","res","shift","byte","RangeError","multiplier","exponentiate","thisByteValue","multiply","add","value","decodeVarint","checkByte","slice","backupOffset","leftBytes","readInt32BE","bytesAvailable","Error","savedOffset","TYPES","decodeProto","reader","parts","trySkipGrpcHeader","checkpoint","byteRange","indexType","parseInt","readVarInt","type","index","readBuffer","push","err","resetToCheckpoint","leftOver","decodeFixed64","floatValue","readDoubleLE","uintValue","intValue","greaterThan","maxLong","subtract","longForComplement","twoComplements","decodeVarintParts","intVal","n","signedIntVal","equal","bitwiseAnd","divide","ProtobufVarintPart","props","map","d","i","key","ProtobufStringOrBytesPart","ProtobufFixed64Part","ProtobufFixed32Part","readFloatLE","readInt32LE","readUInt32LE","decodeFixed32","getProtobufPart","part","decoded","td","TextDecoder","fatal","decode","e","decodeStringOrBytes","ProtobufPart","contents","subType","stringType","typeToString","Table","Row","Cell","join","ProtobufDisplay","celled","Header","HeaderCell","Body","App","useState","setHex","hexBuffer","setHexBuffer","as","Container","Form","Group","TextArea","placeholder","onChange","target","Button","primary","fluid","onClick","Divider","href","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.384e9dae.chunk.js","sourcesContent":["export function parseInput(input) {\n  const normalizedInput = input.replace(/\\s/g, \"\");\n  const normalizedHexInput = normalizedInput.replace(/0x/g, \"\").toLowerCase();\n  if (isHex(normalizedHexInput)) {\n    return Buffer.from(normalizedHexInput, \"hex\");\n  } else {\n    return Buffer.from(normalizedInput, \"base64\");\n  }\n}\n\nexport function isHex(string) {\n  let result = true;\n  for (const char of string) {\n    if (!((char >= \"a\" && char <= \"f\") || (char >= \"0\" && char <= \"9\"))) {\n      result = false;\n    }\n  }\n  return result;\n}\n\nexport function bufferToPrettyHex(buffer) {\n  let output = \"\";\n  for (const v of buffer) {\n    if (output !== \"\") {\n      output += \" \";\n    }\n\n    const hex = v.toString(16);\n    if (hex.length === 1) {\n      output += \"0\" + hex;\n    } else {\n      output += hex;\n    }\n  }\n  return output;\n}\n\nexport function bufferLeToBeHex(buffer) {\n  let output = \"\";\n  for (const v of buffer) {\n    const hex = v.toString(16);\n    if (hex.length === 1) {\n      output = \"0\" + hex + output;\n    } else {\n      output = hex + output;\n    }\n  }\n  return output;\n}\n","import JSBI from \"jsbi\";\n\nconst BIGINT_1 = JSBI.BigInt(1);\nconst BIGINT_2 = JSBI.BigInt(2);\n\nexport function interpretAsSignedType(n) {\n  // see https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wire_format_lite.h#L857-L876\n  // however, this is a simpler equivalent formula\n  const isEven = JSBI.equal(JSBI.bitwiseAnd(n, JSBI.BigInt(1)), JSBI.BigInt(0));\n  if (isEven) {\n    return JSBI.divide(n, BIGINT_2);\n  } else {\n    return JSBI.multiply(\n      JSBI.BigInt(-1),\n      JSBI.divide(JSBI.add(n, BIGINT_1), BIGINT_2)\n    );\n  }\n}\n\nexport function decodeVarint(buffer, offset) {\n  let res = JSBI.BigInt(0);\n  let shift = 0;\n  let byte = 0;\n\n  do {\n    if (offset >= buffer.length) {\n      throw new RangeError(\"Index out of bound decoding varint\");\n    }\n\n    byte = buffer[offset++];\n\n    const multiplier = JSBI.exponentiate(BIGINT_2, JSBI.BigInt(shift));\n    const thisByteValue = JSBI.multiply(JSBI.BigInt(byte & 0x7f), multiplier);\n    shift += 7;\n    res = JSBI.add(res, thisByteValue);\n  } while (byte >= 0x80);\n\n  return {\n    value: res,\n    length: shift / 7\n  };\n}\n","import { decodeVarint } from \"./varintUtils\";\n\nclass BufferReader {\n  constructor(buffer) {\n    this.buffer = buffer;\n    this.offset = 0;\n  }\n\n  readVarInt() {\n    const result = decodeVarint(this.buffer, this.offset);\n    this.offset += result.length;\n\n    return result.value;\n  }\n\n  readBuffer(length) {\n    this.checkByte(length);\n    const result = this.buffer.slice(this.offset, this.offset + length);\n    this.offset += length;\n\n    return result;\n  }\n\n  // gRPC has some additional header - remove it\n  trySkipGrpcHeader() {\n    const backupOffset = this.offset;\n\n    if (this.buffer[this.offset] === 0 && this.leftBytes() >= 5) {\n      this.offset++;\n      const length = this.buffer.readInt32BE(this.offset);\n      this.offset += 4;\n\n      if (length > this.leftBytes()) {\n        // Something is wrong, revert\n        this.offset = backupOffset;\n      }\n    }\n  }\n\n  leftBytes() {\n    return this.buffer.length - this.offset;\n  }\n\n  checkByte(length) {\n    const bytesAvailable = this.leftBytes();\n    if (length > bytesAvailable) {\n      throw new Error(\n        \"Not enough bytes left. Requested: \" +\n          length +\n          \" left: \" +\n          bytesAvailable\n      );\n    }\n  }\n\n  checkpoint() {\n    this.savedOffset = this.offset;\n  }\n\n  resetToCheckpoint() {\n    this.offset = this.savedOffset;\n  }\n}\n\nexport const TYPES = {\n  VARINT: 0,\n  FIXED64: 1,\n  LENDELIM: 2,\n  FIXED32: 5\n};\n\nexport function decodeProto(buffer) {\n  const reader = new BufferReader(buffer);\n  const parts = [];\n\n  reader.trySkipGrpcHeader();\n\n  try {\n    while (reader.leftBytes() > 0) {\n      reader.checkpoint();\n\n      const byteRange = [reader.offset];\n      const indexType = parseInt(reader.readVarInt().toString());\n      const type = indexType & 0b111;\n      const index = indexType >> 3;\n\n      let value;\n      if (type === TYPES.VARINT) {\n        value = reader.readVarInt().toString();\n      } else if (type === TYPES.LENDELIM) {\n        const length = parseInt(reader.readVarInt().toString());\n        value = reader.readBuffer(length);\n      } else if (type === TYPES.FIXED32) {\n        value = reader.readBuffer(4);\n      } else if (type === TYPES.FIXED64) {\n        value = reader.readBuffer(8);\n      } else {\n        throw new Error(\"Unknown type: \" + type);\n      }\n      byteRange.push(reader.offset);\n\n      parts.push({\n        byteRange,\n        index,\n        type,\n        value\n      });\n    }\n  } catch (err) {\n    reader.resetToCheckpoint();\n  }\n\n  return {\n    parts,\n    leftOver: reader.readBuffer(reader.leftBytes())\n  };\n}\n\nexport function typeToString(type, subType) {\n  switch (type) {\n    case TYPES.VARINT:\n      return \"varint\";\n    case TYPES.LENDELIM:\n      return subType || \"len_delim\";\n    case TYPES.FIXED32:\n      return \"fixed32\";\n    case TYPES.FIXED64:\n      return \"fixed64\";\n    default:\n      return \"unknown\";\n  }\n}\n","import JSBI from \"jsbi\";\nimport { bufferLeToBeHex, bufferToPrettyHex } from \"./hexUtils\";\nimport { interpretAsSignedType } from \"./varintUtils\";\n\nexport function decodeFixed32(value) {\n  const floatValue = value.readFloatLE(0);\n  const intValue = value.readInt32LE(0);\n  const uintValue = value.readUInt32LE(0);\n\n  const result = [];\n\n  result.push({ type: \"Int\", value: intValue });\n\n  if (intValue !== uintValue) {\n    result.push({ type: \"Unsigned Int\", value: uintValue });\n  }\n\n  result.push({ type: \"Float\", value: floatValue });\n\n  return result;\n}\n\nexport function decodeFixed64(value) {\n  const floatValue = value.readDoubleLE(0);\n  const uintValue = JSBI.BigInt(\"0x\" + bufferLeToBeHex(value));\n  const intValue = twoComplements(uintValue);\n\n  const result = [];\n\n  result.push({ type: \"Int\", value: intValue.toString() });\n\n  if (intValue !== uintValue) {\n    result.push({ type: \"Unsigned Int\", value: uintValue.toString() });\n  }\n\n  result.push({ type: \"Double\", value: floatValue });\n\n  return result;\n}\n\nexport function decodeVarintParts(value) {\n  const result = [];\n  const intVal = JSBI.BigInt(value);\n  result.push({ type: \"Int\", value: intVal.toString() });\n\n  const signedIntVal = interpretAsSignedType(intVal);\n  if (signedIntVal !== intVal) {\n    result.push({ type: \"Signed Int\", value: signedIntVal.toString() });\n  }\n  return result;\n}\n\nexport function decodeStringOrBytes(value) {\n  if (!value.length) {\n    return { type: \"string|bytes\", value: \"\" };\n  }\n  const td = new TextDecoder(\"utf-8\", { fatal: true });\n  try {\n    return { type: \"string\", value: td.decode(value) };\n  } catch (e) {\n    return { type: \"bytes\", value: bufferToPrettyHex(value) };\n  }\n}\n\nconst maxLong = JSBI.BigInt(\"0x7fffffffffffffff\");\nconst longForComplement = JSBI.BigInt(\"0x10000000000000000\");\n\nfunction twoComplements(uintValue) {\n  if (JSBI.greaterThan(uintValue, maxLong)) {\n    return JSBI.subtract(uintValue, longForComplement);\n  } else {\n    return uintValue;\n  }\n}\n","import React from \"react\";\nimport { Table } from \"semantic-ui-react\";\nimport { decodeProto, TYPES, typeToString } from \"./protobufDecoder\";\nimport {\n  decodeFixed32,\n  decodeFixed64,\n  decodeStringOrBytes,\n  decodeVarintParts\n} from \"./protobufPartDecoder\";\nimport ProtobufDisplay from \"./ProtobufDisplay\";\n\nfunction ProtobufVarintPart(props) {\n  const { value } = props;\n  const decoded = decodeVarintParts(value);\n\n  return decoded.map((d, i) => (\n    <span key={i}>\n      As {d.type}: {d.value}\n      <br />\n    </span>\n  ));\n}\n\nfunction ProtobufStringOrBytesPart(props) {\n  const { value } = props;\n  return value.value;\n}\n\nfunction ProtobufFixed64Part(props) {\n  const { value } = props;\n  const decoded = decodeFixed64(value);\n\n  return decoded.map((d, i) => (\n    <span key={i}>\n      As {d.type}: {d.value}\n      <br />\n    </span>\n  ));\n}\n\nfunction ProtobufFixed32Part(props) {\n  const { value } = props;\n  const decoded = decodeFixed32(value);\n\n  return decoded.map((d, i) => (\n    <span key={i}>\n      As {d.type}: {d.value}\n      <br />\n    </span>\n  ));\n}\n\nfunction getProtobufPart(part) {\n  switch (part.type) {\n    case TYPES.VARINT:\n      return [<ProtobufVarintPart value={part.value} />];\n    case TYPES.LENDELIM:\n      // TODO: Support repeated field\n      let decoded = decodeProto(part.value);\n      if (part.value.length > 0 && decoded.leftOver.length === 0) {\n        return [<ProtobufDisplay value={decoded} />, \"protobuf\"];\n      } else {\n        decoded = decodeStringOrBytes(part.value);\n        return [<ProtobufStringOrBytesPart value={decoded} />, decoded.type];\n      }\n    case TYPES.FIXED64:\n      return [<ProtobufFixed64Part value={part.value} />];\n    case TYPES.FIXED32:\n      return [<ProtobufFixed32Part value={part.value} />];\n    default:\n      return [\"Unknown type\"];\n  }\n}\n\nfunction ProtobufPart(props) {\n  const { part } = props;\n\n  const [contents, subType] = getProtobufPart(part);\n  const stringType = typeToString(part.type, subType);\n\n  return (\n    <Table.Row>\n      <Table.Cell>{part.byteRange.join(\"-\")}</Table.Cell>\n      <Table.Cell>{part.index}</Table.Cell>\n      <Table.Cell>{stringType}</Table.Cell>\n      <Table.Cell>{contents}</Table.Cell>\n    </Table.Row>\n  );\n}\n\nexport default ProtobufPart;\n","import React, { Fragment } from \"react\";\nimport ProtobufPart from \"./ProtobufPart\";\nimport { Table } from \"semantic-ui-react\";\nimport { bufferToPrettyHex } from \"./hexUtils\";\n\nfunction ProtobufDisplay(props) {\n  const { value } = props;\n\n  const parts = value.parts.map((part, i) => {\n    return <ProtobufPart key={i} part={part} />;\n  });\n\n  const leftOver = value.leftOver.length ? (\n    <p>Left over bytes: {bufferToPrettyHex(value.leftOver)}</p>\n  ) : null;\n\n  return (\n    <Fragment>\n      <Table celled>\n        <Table.Header>\n          <Table.Row>\n            <Table.HeaderCell>Byte Range</Table.HeaderCell>\n            <Table.HeaderCell>Field Number</Table.HeaderCell>\n            <Table.HeaderCell>Type</Table.HeaderCell>\n            <Table.HeaderCell>Content</Table.HeaderCell>\n          </Table.Row>\n        </Table.Header>\n\n        <Table.Body>{parts}</Table.Body>\n      </Table>\n      {leftOver}\n    </Fragment>\n  );\n}\n\nexport default ProtobufDisplay;\n","import React, { Fragment, useState } from \"react\";\nimport { Container, Divider, Form, Header, TextArea } from \"semantic-ui-react\";\nimport { parseInput, bufferToPrettyHex } from \"./hexUtils\";\nimport \"./App.css\";\nimport ProtobufDisplay from \"./ProtobufDisplay\";\nimport { decodeProto } from \"./protobufDecoder\";\n\nfunction App() {\n  const [hex, setHex] = useState(\"\");\n  const [hexBuffer, setHexBuffer] = useState(\"\");\n\n  const onHexChanged = e => {\n    setHex(e.target.value);\n  };\n\n  const onSubmit = () => {\n    const buffer = parseInput(hex);\n\n    // Set pretty hex back to UI\n    setHex(bufferToPrettyHex(buffer));\n\n    // Set to hexBuffer which will be sent to render\n    setHexBuffer(buffer);\n  };\n\n  const result = hexBuffer ? (\n    <Fragment>\n      <Header as=\"h2\">Result</Header>\n      <ProtobufDisplay value={decodeProto(hexBuffer)} />\n    </Fragment>\n  ) : null;\n\n  return (\n    <Container>\n      <Header as=\"h1\">Protobuf Decoder</Header>\n      <p>\n        Tool to decode Protobuf without having the original .proto files. All\n        decoding is done locally via JavaScript.\n      </p>\n      <Form>\n        <Form.Group>\n          <TextArea\n            placeholder=\"Paste Protobuf or gRPC request as hex or base64\"\n            onChange={onHexChanged}\n            value={hex}\n          />\n        </Form.Group>\n        <Form.Button primary fluid onClick={onSubmit}>\n          Decode\n        </Form.Button>\n      </Form>\n      {result}\n      <Divider />\n      <p>\n        Made by pawitp. Contribute on{\" \"}\n        <a href=\"https://github.com/pawitp/protobuf-decoder\">GitHub</a>.\n      </p>\n    </Container>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport \"semantic-ui-css/semantic.min.css\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}